name: Deploy to EC2

on:
  release:
    types: [ published ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read
  packages: read

env:
  IMAGE_NAME: ghcr.io/${{ github.repository }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    environment:
      name: production

    steps:
      - name: Resolve IMAGE_TAG
        id: tag
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            TAG="${{ github.event.release.tag_name }}"
            echo "image_tag=${TAG#v}" >> $GITHUB_OUTPUT
            echo "repo_ref=${TAG}"    >> $GITHUB_OUTPUT
          else
            echo "image_tag=latest"   >> $GITHUB_OUTPUT
            echo "repo_ref=main"      >> $GITHUB_OUTPUT
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS creds (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region:     ${{ vars.AWS_REGION }}

      - name: Deploy via SSM
        env:
          INSTANCE_ID: ${{ vars.INSTANCE_ID }}
          APP_DIR:     ${{ vars.APP_DIR }}
          IMAGE_NAME:  ${{ env.IMAGE_NAME }}
          IMAGE_TAG:   ${{ steps.tag.outputs.image_tag }}
          REPO_REF:    ${{ steps.tag.outputs.repo_ref }}
          SPRING_PROFILES_ACTIVE: ${{ vars.SPRING_PROFILES_ACTIVE }}
          TELEGRAM_BOT_TOKEN:     ${{ secrets.TELEGRAM_BOT_TOKEN }}
          GRAFANA_ADMIN_USER:     ${{ vars.GRAFANA_ADMIN_USER }}
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
          REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          SCRIPT=$(cat <<'EOS'
          set -eo pipefail

          mkdir -p "$APP_DIR"
          cd "$APP_DIR"
          
          mkdir -p config
          mkdir -p monitoring/grafana/datasources
          mkdir -p monitoring/grafana/dashboards
          mkdir -p monitoring/prometheus

          if [ ! -f .env ]; then
            umask 077
            : > .env
          fi

          curl -fsSL -o compose.yml "https://raw.githubusercontent.com/${REPOSITORY}/${REPO_REF}/compose.yml" || \
          curl -fsSL -o compose.yml "https://raw.githubusercontent.com/${REPOSITORY}/main/compose.yml"

          curl -fsSL -o prometheus.yml "https://raw.githubusercontent.com/${REPOSITORY}/${REPO_REF}/prometheus.yml" || \
          curl -fsSL -o prometheus.yml "https://raw.githubusercontent.com/${REPOSITORY}/main/prometheus.yml"
          
          curl -fsSL -o monitoring/prometheus/rules.yml "https://raw.githubusercontent.com/${REPOSITORY}/${REPO_REF}/monitoring/prometheus/rules.yml" || \
          curl -fsSL -o monitoring/prometheus/rules.yml "https://raw.githubusercontent.com/${REPOSITORY}/main/monitoring/prometheus/rules.yml"

          curl -fsSL -o config/sources.yml "https://raw.githubusercontent.com/${REPOSITORY}/${REPO_REF}/config/sources.yml" || \
          curl -fsSL -o config/sources.yml "https://raw.githubusercontent.com/${REPOSITORY}/main/config/sources.yml"
          
          curl -fsSL -o monitoring/grafana/datasources/prometheus.yml "https://raw.githubusercontent.com/${REPOSITORY}/${REPO_REF}/monitoring/grafana/datasources/prometheus.yml" || \
          curl -fsSL -o monitoring/grafana/datasources/prometheus.yml "https://raw.githubusercontent.com/${REPOSITORY}/main/monitoring/grafana/datasources/prometheus.yml"
          
          curl -fsSL -o monitoring/grafana/dashboards.yml "https://raw.githubusercontent.com/${REPOSITORY}/${REPO_REF}/monitoring/grafana/dashboards.yml" || \
          curl -fsSL -o monitoring/grafana/dashboards.yml "https://raw.githubusercontent.com/${REPOSITORY}/main/monitoring/grafana/dashboards.yml"
          
          for f in downloader-bot.json jvm-micrometer.json redis.json; do
            curl -fsSL -o "monitoring/grafana/dashboards/${f}" "https://raw.githubusercontent.com/${REPOSITORY}/${REPO_REF}/monitoring/grafana/dashboards/${f}" || \
            curl -fsSL -o "monitoring/grafana/dashboards/${f}" "https://raw.githubusercontent.com/${REPOSITORY}/main/monitoring/grafana/dashboards/${f}"
          done

          chmod 0644 config/sources.yml || true
          find monitoring -type f -name "*.yml" -exec chmod 0644 {} \; || true
          find monitoring -type f -name "*.json" -exec chmod 0644 {} \; || true
          
          min_free_mb=${MIN_FREE_MB:-2048}
          free_mb=$(df -Pm / | awk 'NR==2{print $4}')
          echo "Free space on /: ${free_mb} MB (need >= ${min_free_mb} MB)"
          if [ "$free_mb" -lt "$min_free_mb" ]; then
              docker container prune -f || true
              docker image prune -af || true
              docker builder prune -af || true
              docker volume prune -f || true
              sudo journalctl --vacuum-time=7d || true
              sudo apt-get clean || true
          fi

          docker compose pull
          docker compose --profile monitoring up -d --remove-orphans

          ok=0
          for i in $(seq 1 24); do
            CID="$(docker compose ps -q app 2>/dev/null || true)"
            STATUS="unknown"
            if [ -n "${CID:-}" ]; then
              STATUS="$(docker inspect --format '{{.State.Health.Status}}' "$CID" 2>/dev/null || echo unknown)"
            fi
            echo "app health=$STATUS"
            if [ "$STATUS" = "healthy" ]; then ok=1; break; fi
            sleep 5
          done

          if [ "$ok" -ne 1 ]; then
            echo "!! unhealthy after update"
            docker compose logs --no-color --since=10m app || true
            exit 1
          fi

          docker image prune -f || true
          EOS
          )

          SCRIPT_B64=$(printf '%s' "$SCRIPT" | base64 -w0)

          PARAMS_JSON=$(jq -n \
          --arg img  "$IMAGE_NAME" \
          --arg tag  "$IMAGE_TAG" \
          --arg repo "$REPOSITORY" \
          --arg repo_ref "$REPO_REF" \
          --arg tok  "$TELEGRAM_BOT_TOKEN" \
          --arg prof "$SPRING_PROFILES_ACTIVE" \
          --arg gfu  "$GRAFANA_ADMIN_USER" \
          --arg gfp  "$GRAFANA_ADMIN_PASSWORD" \
          --arg dir  "$APP_DIR" \
          --arg b64  "$SCRIPT_B64" \
          '{
            commands: [
              ("export IMAGE_NAME=\"" + $img + "\""),
              ("export IMAGE_TAG=\"" + $tag + "\""),
              ("export REPOSITORY=\"" + $repo + "\""),
              ("export REPO_REF=\"" + $repo_ref + "\""),
              ("export TELEGRAM_BOT_TOKEN=\"" + $tok + "\""),
              ("export GRAFANA_ADMIN_USER=\"" + $gfu + "\""),
              ("export GRAFANA_ADMIN_PASSWORD=\"" + $gfp + "\""),
              ("export SPRING_PROFILES_ACTIVE=\"" + $prof + "\""),
              ("export APP_DIR=\"" + $dir + "\""),
          
              ("echo " + $b64 + " | base64 -d > /tmp/deploy.sh"),
              "chmod +x /tmp/deploy.sh",
          
              "/usr/bin/env bash -euo pipefail /tmp/deploy.sh"
            ],
            executionTimeout: ["3600"]
          }')


          COMMAND_ID=$(aws ssm send-command \
            --cli-binary-format raw-in-base64-out \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy downloader-bot ${IMAGE_NAME}:${IMAGE_TAG}" \
            --parameters "$PARAMS_JSON" \
            --query "Command.CommandId" \
            --output text)

          echo "SSM CommandId: $COMMAND_ID"
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID"

          RES_JSON=$(aws ssm list-command-invocations --command-id "$COMMAND_ID" --details --output json)
          STATUS=$(echo "$RES_JSON" | jq -r '.CommandInvocations[0].Status')
          EXIT_CODE=$(echo "$RES_JSON" | jq -r '.CommandInvocations[0].CommandPlugins[0].ResponseCode')
          OUT=$(echo "$RES_JSON" | jq -r '.CommandInvocations[0].CommandPlugins[0].Output // ""')
          ERRURL=$(echo "$RES_JSON" | jq -r '.CommandInvocations[0].CommandPlugins[0].StandardErrorUrl // empty')

          echo "SSM Status: $STATUS"
          echo "ExitCode: ${EXIT_CODE:-unknown}"
          echo "----- STDOUT -----"
          echo "$OUT"
          [ -n "$ERRURL" ] && echo "STDERR URL: $ERRURL"

          if [ "$STATUS" != "Success" ] || [ "${EXIT_CODE:-0}" -ne 0 ]; then
            echo "Deployment failed via SSM"
            exit 1
          fi
